# 操作系统

> 王道考研操作系统教程：BV1YE411D7nH

## 2. 进程和线程

### 2.1 进程

#### 2.1.1 基本概念

*   程序段、数据段和 PCB 三部分组成进程实体（进程映像），通常将进程实体简称为进程
*   创建进程和撤销进程实际上是创建/撤销进程实体中的 PCB
*   进程从不同角度可以由不同定义
    -   进程是程序的一次执行过程
    -   进程是一个程序及其数据在处理机上顺序执行时所发生的活动
    -   进程时具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的独立单位
    -   进程是进程实体的运行过程，是系统改进型资源分配和调度的独立单位

#### 2.2 进程控制块 PCB

*   进程描述信息
    -   进程标识符 PID
    -   用户标识符 UID
*   进程控制和管理信息
    -   进程当前状态
    -   进程优先级
*   资源分配清单
    -   CS 段指针
    -   DS 段指针
    -   键盘/鼠标等
*   处理机相关信息
    -   各种寄存器值

#### 2.1.3 进程的组织

*   进程的组织方式
    -   链接方式
        -   按照进程状态，将 PCB 分为多个队列
        -   操作系统持有指向各个队列的指针
    -   索引方式
        -   根据进程状态的不同，建立几张索引表
        -   操作系统持有指向各个索引表的指针

#### 2.1.4 进程的特征

*   动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的，是进程最基本的特性
*   并发性：内存中由多个进程实体，各进程可并发执行
*   独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
*   异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供”进程同步机制“解决异步问题
*   结构性：每一个进程都会配置一个 PCB

### 2.2 进程的状态与转换

#### 2.2.1 进程的基本状态

*   运行态 Running ：占有 CPU ，并在 CPU 上运行
*   就绪态 Ready ：已经具备运行条件，但是由于没有空闲 CPU 而暂时不能运行
*   阻塞态 Blocked / Waiting ：因等待事件不能运行
*   创建态 New ：进程正在被创建，操作系统为进程分配资源、初始化 PCB
*   终止态 Terminated ：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销 PCB

#### 2.2.2 进程状态的转换

进程状态的转换如下图所示

### 2.3 进程控制

#### 2.3.1 基本概念

*   进程控制的主要功能是对系统中的所有进程实施有效的管理
*   进程控制具有创建新进程、撤销已有进程、实现进程状态转换等功能
*   进程控制需要原子操作，因此用原语实现进程控制
*   原语采用关中断指令和开中断指令实现
*   控制进程的原语需要做三件事情
    -   更新 PCB 中的信息，如修改进程状态标志、将运行环境保存到 PCB ，从 PCB 恢复运行环境等
        -   所有的进程控制原语一定都会修改进程状态标志
        -   剥夺当前运行进程的 CPU 使用权必然需要保存其运行环境
        -   某进程开始运行前必然要恢复其运行环境
    -   将 PCB 插入合适的队列
    -   分配/回收资源

#### 2.3.2 原语

> TODO: 原语列表

### 2.4 进程通信

#### 2.4.1 共享储存

*   为了保证安全，一个进程不能直接访问另一个进程的地址空间，需要使用操作系统提供的方法
*   操作系统为进程分配一个共享空间，供两个进程**互斥**地访问
*   操作系统只负责提供共享空间和同步互斥工具
*   基于储存区的共享：在内存中划出一块共享储存区，数据的形式和存放位置都由进程控制

#### 2.4.2 管道通信

*   管道是用于连接读写进程的一个共享文件（实际上是在内存中开辟的一个固定大小的缓冲区），只能提供半双工的通信
*   各进程访问管道应该是**互斥**的
*   数据以字符流的形式写入管道，当管道写满时，写进程的 `write()` 被阻塞，等待读进程取走数据
*   读进程将数据读出后，管道变空，此时读进程的 `read()` 被阻塞
*   如果管道没有写满则不允许读取，如果没有读空则不允许写入
*   数据一旦从管道中读出就被抛弃，这一位置额读进程**最多只能有一个**，否则会有读错数据的情况

#### 2.4.3 消息传递

*   进程间的数据以格式化的消息为单位，进程通过操作系统提供的原语进行数据交换
*   直接通信方式：消息直接挂到接收进程的消息缓冲队列上
*   间接通信方式：消息要先发送到中间实体（信箱）中

### 2.5 线程

#### 2.5.1 基本概念

*   线程是一种“轻量级进程”，是一个基本的 CPU 执行单元，也是程序执行流的最小单位
*   引入线程后，进程只作为除 CPU 之外的系统资源的分配单元
*   引入线程机制后的变化
    -   资源分配调度
        -   传统进程机制中，进程是资源分配调度的基本单位
        -   引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
    -   并发性
        -   传统进程机制中，只能进程间并发
        -   引入线程后，各线程之间也能并发
    -   系统开销
        -   传统进程机制中，并发会导致运行环境频繁切换，系统开销较大
        -   引入线程后，线程间并发如果在同一进程下，则不需要切换进程环境，系统开销减小
*   线程的属性

> TODO: 线程属性

#### 2.5.2 线程的实现方式

*   用户级线程
    -   由应用程序通过线程库实现
    -   所有的线程管理工作都由应用程序负责
    -   线程切换可以在用户态下完成，无需操作系统干预
    -   用户级线程对用户不透明，对操作系统透明
*   内核级线程
    -   由操作系统完成线程管理、调度和切换
    -   线程切换在核心态下完成
*   实际实现时可以采用两者组合的方式，即将用户线程映射到内核线程上

### 2.6 处理机调度

#### 2.6.1 高级调度

*   高级调度（作业调度）：按照一定的原则从外存上处于后备队列的作业中挑选一个或多个作业，分配内存等必要资源并建立 PCB ，以使它们获得竞争处理机的权利
*   高级调度是外存与内存之间的调度，每个作业只调入一次，调出一次。调入时会建立对应的 PCB ，调出时会撤销对应的 PCB
*   高级调度主要是调入问题，因为调出的时机必然是作业运行结束的时机

#### 2.6.2 中级调度

*   中级调度（内存调度）：决定将哪个处于挂机状态的进程重新调入内存
*   引入虚拟储存技术后，可将暂时不能运行的进程通过挂起原语调入外存等待
*   PCB 不会随挂起原语调用到外存，而是会常驻内存，操作系统通过内存中的 PCB 保持对各个进程的监控和管理
*   被挂起的进程 PCB 会被放入挂起队列中
*   加入挂起唤醒原语后，五状态模型变为七状态模型

#### 2.6.3 低级调度

*   低级调度（进程调度）：按照某种方法和策略从就绪队列中选取一个进程，将 CPU 分配给它
*   进程调度是操作系统中最基本的一种调度
*   进程调度的频率很高，约几十毫秒一次
*   进程调度的时机
    -   当前运行的进程主动放弃 CPU 时，如进程正常终止，发生异常，进程请求阻塞等
    -   当前运行的进程被动放弃 CPU 时，如时间片用完，有更紧急的事件需要处理，更高优先级的进程进入就绪队列等
    -   处理中断的过程中、进程在操作系统内核程序临界区中和原子操作过程中不能进行进程的调度与切换
*   进程调度的方式
    -   非剥夺调度方式（非抢占方式）：只允许进程主动放弃 CPU ，在运行过程中即使有更高优先级任务到达，当前进程依然继续占用 CPU ，直到进程终止或主动进入阻塞
    -   剥夺调用方式（抢占方式）：进程执行过程中，如果有更高优先级任务到达，立即暂停正在执行的进程并将 CPU 分配给刚到达的进程

#### 2.6.4 调度算法

*   调度算法的评价指标

    -   CPU 利用率：CPU 忙碌时间占总时间的比例
    -   系统吞吐量：单位时间内完成作业的数量
    -   周转时间：从作业被提交开始到作业完成的时间间隔，包括高级调度、低级调度、进程执行和进程等待 I/O 的时间
    -   带权周转时间：周转时间除以作业实际运行时间
    -   等待时间：作业处于等待 CPU 状态的时间之和
    -   响应时间：从用户提交请求到首次产生响应的时间

*   FCFS（先来先服务）

    -   按作业的到达顺序进行服务
    -   用于作业调度时，考虑哪个作业先到达后备队列；用于进程调度时，考虑哪个进程先到达就绪队列
    -   是非抢占式的算法
    -   优缺点
        -   优点：公平，算法相对简单
        -   缺点：排在长作业后的短作业等待时间过长，带权周转时间很大，对长作业有利，对短作业不利
    -   不会导致饥饿（某作业长期得不到服务）

*   SJF（短作业优先）

    -   最短（要求服务时间）的作业优先得到服务
    -   用于进程调度时，称为 SPF（短进程优先）算法
    -   非抢占式，但是有抢占式的改进算法 （ SRTN ，最短剩余时间优先）
    -   在所有进程几乎同时到达时，SJF 的平均等待时间和平均周转时间最少；一般情况下 SRTN 的平均等待时间和平均周转时间最少
    -   优缺点
        -   优点：”最短“平均等待时间和平均周转时间
        -   缺点：对短作业有利，对长作业不利；作业的运行时间由用户提供，不一定真实
    -   会导致饥饿，甚至会导致长作业饿死

*   HRRN （高响应比优先）

    -   每次调度时优先计算各个作业的响应比，选择响应比较高的作业优先服务。$响应比=\frac{等待时间+要求服务时间}{要求服务时间}$
    -   非抢占式，只有当前作业主动放弃 CPU 时才需要计算响应比重新调度
    -   优缺点
        -   优点：综合考虑了等待时间和运行时间，等待时间相同时运行时间短的优先，长作业等待时间越久响应比也越大，从而避免了长作业饥饿
        -   缺点：用户交互性差
    -   不会导致饥饿

*   RR（时间片轮转调度算法）

    -   公平、轮流为各个进程服务，让每个进程在一定时间间隔内都能得到响应
    -   按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，若进程未在一个时间片内执行完则重新放入就绪队列队尾
    -   是抢占式算法，由时钟装置发出时钟中断通知 CPU 时间片已到
    -   如果时间片过大，则 RR 退化为 FCFS
    -   优缺点
        -   优点：公平，响应快，适合分时系统
        -   缺点：高频率的进程切换，不区分任务紧急程度
    -   不会导致饥饿

*   优先级调度算法

    -   调度时选择优先级最高的作业
    -   抢占式和非抢占式都有
    -   就绪队列未必只有一个，可以按照不同优先级来组织，另外也可以优先级高的进程排在更靠近队头的位置
    -   根据优先级是否可变，分为静态优先级和动态优先级
    -   通常系统进程优先级高于用户进程，前台进程优先级高于后台进程，I/O 繁忙型进程优先级高于 CPU 繁忙型（计算型）进程
    -   动态优先级调整时，如果进程在就绪队列中等待很长时间，可以提高优先级；如果占用 CPU 时间过长，可以降低优先级；如果频繁进行 I/O 操作，可以适当提升优先级
    -   优缺点
        -   优点：灵活调整各种作业的偏好程度，适用于实时操作系统
        -   缺点：高优先级进程过多时，会导致低优先级进程饥饿
    -   会导致饥饿

*   多级反馈队列调度算法

    -   多级队列调度是对其他调度算法的折中权衡
        -   设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
        -   新进程到达时先进入第一级队列，按 FCFS 原则排队等待分配时间片
        -   如果用完时间片进程还未结束，放入下一级队列队尾（如果已经在最下级则直接放入队尾）
        -   只有第 k 级队列空时，才会为 k+1 级对头的进程分配时间片
    -   抢占式算法，在进程运行时，如果更上级队列进入了一个新进程，则新进程抢占 CPU ，原来运行的进程放入其所在级别队列的队尾
    -   优缺点
        -   优点：对各类进程相对公平，新到达进程可以快速得到响应，短进程只需要较少时间就可以执行完成，不需要估计进程运行时间；可以灵活调整对各类进程的偏好程度（如将因 I/O 阻塞的进程重新放回原队列使 I/O 繁忙型进程保持较高优先级）
        -   缺点：低等级队列的进程可能长期得不到服务
    -   会导致饥饿

### 2.7 同步与互斥

#### 2.7.1 线程同步

*   同步（直接制约关系）是指为完成某种任务而建立的两个或多个进程之间，因为需要在某些位置上协调它们的工作次序而产生的制约关系

    -   进程间的直接制约关系源于它们之间的相互合作

#### 2.7.2 线程互斥

-   系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内仅允许**一个进程**访问该资源

-   一个时间段内只允许一个进程使用的资源称为临界资源

*   互斥（间接制约关系）指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程结束访问释放资源后，另一个进程才能去访问临界资源

    -   对临界资源的互斥访问，在逻辑上可以分为如下四个部分

    ```c++
    
        do
        {
            EntrySection(); 		// 进入区
            CriticalSection(); 	// 临界区
            ExitSection(); 	    // 退出区
            RemainderSection(); 	// 剩余区
        } while(true)
    
    ```
*   每个区域所做的工作如下

    -   进入区负责检查是否可进入临界区，若可进入，则设置正在访问临界资源的标志，即**上锁**
    -   临界区是访问临界资源的代码
    -   退出区负责解除正在访问临界资源的标志，即**解锁**
    -   剩余区做其他处理

*   实现临界资源互斥访问需要遵循以下原则

    -   空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
    -   忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
    -   有限等待：对请求访问的进程，应保证其能在有限时间内进入临界区
    -   让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

#### 2.7.3 进程互斥的实现方法

> 本节中用 `Critical` 表示临界区，用 `Remainder` 表示剩余区

*   单标志法：两个进程在访问完成后会把临界区使用权限交给另一个进程，即每个进程进入临界区的权限只能被另一个进程赋予

    ```c++
        int turn = 0;	// turn 表示当前允许进入临界区的进程号

        // 进程 P0
        {
            while(turn != 0)    // 进入区
            Critical;           // 临界区
            turn = 1;           // 退出区
            Remainder;          // 剩余区
        }

        // 进程 P1
        {
            while(turn != 1)    // 进入区
            Critical;           // 临界区
            turn = 0;           // 退出区
            Remainder;          // 剩余区
        }
    ```

    -   对于临界区的访问，一定是按照 P0 $\rarr$ P1 $\rarr$ P0 $\cdots$ 的顺序进行的
    -   如果此时允许 P0 进入临界区，但 P0 一直不访问，P1 也就一直不能访问空闲的临界区，违背空闲让进原则

*   双标志先检查法：设置一个 `bool` 型数组用来标记各进程想进入临界区的意愿，每个进程在进入临界区前先检查当前有没有别的进程想进入临界区

    ```c++
        bool flags[2] = {false, false};

        // 进程 P0
        {
            while(flag[1]);             //- 1
            flag[0] = true; Critical;   //- 2
            flag[0] = false;            //- 3
            Remainder;                  //- 4
        }

        // 进程 P1
        {
            while(flag[0]); //- 5
            flag[1] = true; Critical; //- 6
            flag[1] = false; //- 7
            Remainder; //- 8
        }
    ```

    - 当执行顺序是 1-5-2-6-... 时， P0 和 P1 将同时访问临界区，违背忙则等待原则
    - 原因是进入区的检查和上锁操作不是一次性处理完的，其中可能会存在进程切换

*   双标志后检查法：先检查法的改进，在检查之前先上锁。具体做法是将上述代码的 `flag[i] = true` 提到 `while` 循环之前。可能会导致两个进程都锁住临界区而无法进入，违背了空闲让进和有限等待。

*   Peterson 算法：在双标志后检查法中，如果双方都抢着进入临界区，可以让进程选择主动让对方进入临界区

    ```c++
        bool flag[2] = {false, false};
        int trun = 0;   // 表示优先让哪个进程进入临界区
    
        // 进程 P0
        {
            flag[0] = true;
            trun = 1;
            while(flag[1] && trun == 1);
            Critical;
            flag[0] = false;
            Remainder;
        }
    
        // 进程 P1
        {
            flag[1] == true;
            trun = 0;
            while(flag[0] && trun == 0); // 对方想进入，并且最后一次是自己让出进入权，那么自己等待
            Critical；
            flag[1] = false;
            Remainder;
        }
    ```

    - Peterson 算法解决了空闲让进、忙则等待和有限等待原则，但是没有解决让权等待原则

-   中断屏蔽方法：利用中断的原子性，在访问临界区前关中断，访问完成后开中断

    - 优点：简单，高效
    - 缺点：不适用于多处理机，只适用于操作系统内核进程

-   TestAndSetLock 指令：由硬件实现的原子指令，也称 TSL 指令，C 语言描述如下

    ```c++
        // lock 表示临界区是否加锁
        bool TestAndSet(bool& lock)
        {
            bool old = lock;
            lock = true;   // 无论之前是否加锁，现在都锁上
            return old;     // 返回 lock 原来的值
        }

        // 进程 P0
        {
            while(TestAndSet(lock));
            Critical;
            lock = false;
            Remainder;
        }
    ```

    - 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
    - 缺点：不满足让权等待原则，暂时无法进入临界区的程序会占用 CPU 并循环 TSL 指令，从而导致忙等

-   Swap 指令：也称 XCHG 指令，由硬件实现的原子指令，C 语言描述如下

    ```c++
        void Swap(bool& a, bool& b)
        {
            bool tmp = a;
            a = b;
            b = tmp;
        }
    
        // 进程 P0
        {
            bool old = true;
            while(old == true) Swap(lock, old);
            Critical;
            lock = false;
            Remainder;
        }
    ```

    - 优缺点和 TSL 指令相似

### 2.8 信号量机制

#### 2.8.1 信号量

- 用户可以通过操作系统提供的一对原语来对信号量进行操作

- 信号量是一个变量，可以用一个信号量来表示某种资源的数量

- 原语是一种特殊程序段，由关中断/开中断指令实现，其执行只能一气呵成，不可被中断

- wait 和 signal 原语常简写为 P/V 操作（源自荷兰语 proberen ”检测“ 和 verhogen ”增量“)

- 整型信号量

    - 用一个整数型变量作为信号量，用来表示某种资源的数量

    - 只由三种操作：初始化和 P/V 操作

        ```c++
            int S = 1;  // 系统中有一台打印机

            void P(int S)
            {
                while(S <= 0); // 进入区。如果资源数不够，就一直循环等待
                S -= 1;
            }

            void V(int S)
            {
                S += 1; // 退出区，使用完资源后释放
            }

            // 进程 P0
            {
                P(S);   // 进入区，申请资源
                Critical；
                V(S);   // 退出区，释放资源
                Remainder;
            }
        ```

    - 整型信号量检查和上锁操作是原子操作，避免并发异步导致的问题，但是不满足让权等待原则

- 记录型信号量

    - 记录型信号量不仅保存剩余资源数，还保存一个指向等待队列的指针

        ```c++
            struct Semaphore
            {
                int value;          // 剩余资源数
                ProcessList list;   // 等待队列
            };

            void P(Semaphore S)
            {
                S.value -= 1;
                if(S.value < 0)
                {
                    Block(S.list);  // 如果剩余资源数不足，使用 block 原语
                                    // 进程从运行态进入阻塞态，并挂载到 S 的等待队列
                }
            }

            void V(Semaphore S)
            {
                S.value += 1;
                if(S.value <= 0)
                {
                    Wakeup(S.list); // 释放完成后，如果还有进程在等待资源
                                    // 使用 wakeup 原语从等待队列唤醒一个进程
                }
            }
        ```

    - 记录型信号量实现了让权等待原则

#### 2.8.2 进程互斥与进程同步

- 信号量机制实现进程互斥

    - 分析并发进程的关键活动，划定临界区

    - 设定互斥信号量 mutex ，初始值为 1

    - 在临界区前执行 `P(mutex)` ，临界区之后执行 `V(mutex)`

- 信号量机制实现进程同步

    - 分析什么地方需要实现同步关系

    - 设置同步信号量 S ，初始值为 1
    
    - 在前操作之后执行 `V(S)` ，在后操作之前执行 `P(S)`

- 信号量实现前驱关系

    - 按照进程同步方式，为每一对前驱关系设置同步变量，并执行 V/P 操作

- 互斥信号量的 P 操作一定要在同步信号量的 P 操作之后，否则可能导致死锁

### 2.9 管程

- 信号量机制编写程序困难、易出错，因此引入了管程用来实现同步

- 管程是一种特殊的软件模块，由以下部分组成

    - 局部于管程的共享数据结构说明

    - 对该数据结构进行操作的一组过程

    - 对局部于管程的共享数据设置初始值的语句

    - 管程名

- 管程的基本特征

    - 局部于管程的数据只能被局部于管程的过程所访问

    - 一个进程只有通过调用管程内的过程才能进入管程访问共享数据

    - 每次**仅允许一个**进程在管城内执行某个内部过程

### 2.10 死锁

#### 2.10.1 死锁的定义

- 并发环境下，各个进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象称为死锁

- 死锁发生后，若没有外力干涉，所有死锁的进程都无法继续推进

- 死锁、饥饿和死循环的区别

    - 死锁是各进程互相等待对方手里的资源，死锁的进程一定处于阻塞态

    - 饥饿是指由于长期得不到资源，进程无法推进，饥饿的进程可能处于阻塞态和就绪态

    - 死循环是指进程执行过程中一直跳不出某个循环，死循环是被管理者的问题，不是操作系统的问题

- 死锁发生的条件

    - 互斥条件：只有对必须互斥使用的资源的抢夺才会导致死锁

    - 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走

    - 请求和保持条件：进程已经保存了至少一个资源，但又提出了新的资源请求，而该资源被其他进程占有，此时请求进程被阻塞，但又对自己的资源保持不放

    - 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程所请求

- 死锁的发生原因

    - 对系统资源的竞争

    - 进程推进顺序非法

    - 信号量使用不当（可以将信号量视为一种抽象的资源）

#### 2.10.2 死锁的处理方法

- 预防死锁
  
  - 处理思想：破坏死锁四条件其中的一个或多个

  - 破坏互斥条件：将只能互斥使用的资源改造为允许共享使用，缺点是应用很窄，不符合系统安全

  - 破坏不剥夺条件：当进程请求新的资源得不到满足时，立即释放所保持的所有资源，或者由操作系统协助剥夺其他进程的资源，缺点是实现复杂，释放已有资源可能造成前一阶段工作的失效，增加系统的吞吐量且导致饥饿

  - 破坏请求保持条件：采用静态分配方法，即在进程运行前一次性申请它所用的所有资源，缺点是资源利用率极低，造成严重资源浪费

  - 破坏循环等待条件：可以采用顺序资源分配法，规定每个进程必须按照编号递增的顺序请求资源，同类资源一次申请完，缺点是不方便增加新设备，进程实际使用顺序和编号不一致时会导致资源浪费，编码较为麻烦

- 避免死锁

  - 安全序列是指如果系统按照这种序列分配资源，则每个进程都能顺利完成，此时称系统为安全状态

  - 如果分配资源后，系统中找不出任何一个安全序列，则称系统进入了不安全状态，之后可能所有进程都无法顺利执行（如果有些进程提前归还资源，系统有可能回到安全状态）

  - 如果系统处于安全状态，就一定不会发生死锁；如果系统进入不安全状态则有可能发生死锁

  - 银行家算法

    - 核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会，就暂时不答应这次请求，让该进程先阻塞等待

    - 假设系统中由 m 种资源，n 个进程，每个进程在运行前声明各种资源的最大需求数并记录在最大需求矩阵 $Max_{n\times m}$ 中。系统用一个分配矩阵 $Alloc_{n\times m}$ 记录进程的资源分配情况， $Max - Alloc = Need$ 表示各进程最多还需要多少各类资源。用 $Avail$ 表示目前可用的各类资源数目，$Request_i$ 表示进程 i 本次申请的各种资源量，则银行家算法的过程如下

      1. 如果 $Request_i[j]\leq Need[i][j]$ ，转到 2 ，否则认为出错
      2. 如果 $Request_i[j]\leq Avail[j]$ ，转到 3 ，否则表示尚无足够资源，需要等待
      3. 系统尝试将资源分配给进程，并修改相应的数据
      4. 操作系统执行安全性算法，检查此次分配后系统是否处于安全状态。如果安全，正式分配资源；否则恢复相应数据，进程阻塞等待

    - 安全性算法：检查当前剩余可用资源是否能满足某进程的最大需求。如果可以，就把该进程加入安全序列，并将该进程持有的资源全部回收，不断重复看能否让所有进程都加入安全序列。

- 死锁的检测和解除

    - 检测算法

        - 用某种数据结构来保存资源的请求和分配信息

        - 提供算法利用上述信息检测系统是否进入死锁状态

    - 资源分配图

        - 节点分进程节点（对应一个进程）和资源节点（对应一类资源，每类资源可能有多个）

        - 边分进程指向资源（表示进程想申请几个资源，每条边代表一个）和资源指向进程（表示已经为进程分配了几个资源）

        - 在资源检测图中，找出既不阻塞又不是孤立点的进程 P（有有向边与之相连，且该有向边对应资源申请数量不大于系统中已有空闲资源数），消去其所有的请求边和分配边，使其成为孤立的节点

        - 重复进行上述操作，如果能够消除所有边（图可以完全简化），此时一定没有发生死锁，如果不能消除所有边，则此时发生了死锁，最终连着边的节点就是死锁的节点

    - 解除算法

        - 资源剥夺法：挂起某些死锁进程，并抢占其资源，将这些资源分配给其他的死锁进程。但是要防止被挂起的进程长时间得不到资源而饥饿

        - 撤销进程法：强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源

        - 进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步，要求系统记录进程的历史信息，设置还原点

        - 可以从进程优先级、进程已执行时间、进程剩余时间、进程已使用资源和进程属于交互式/批处理式等角度考虑从哪个死锁进程下手

#
- 上一节：[操作系统基本概念](./OperatingSystems_01.md)
- 下一节：[内存管理](./OperatingSystems_03.md)