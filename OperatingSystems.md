# 操作系统

> 王道考研操作系统教程：BV1YE411D7nH

## 1. 操作系统基本概念

### 1.1 操作系统的定义

*   计算机系统的层次结构（由下到上）

    -   计算机硬件
    -   操作系统
    -   计算机软件
    -   用户（用户可以直接和操作系统进行部分交互）

*   操作系统作用

    -   操作系统负责管理协调硬件、软件等计算机资源的工作
    -   为上层的应用程序和用户提供简单易用的服务

*   操作系统定义

    操作系统是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的计算机系统中最基本的**系统软件**。

### 1.2 操作系统的功能和目标

*   作为系统资源的管理者

    -   处理机管理
    -   存储器管理（内存管理）
    -   文件管理
    -   设备管理

*   作为用户和计算机硬件之间的接口

    -   命令接口

        -   联机命令接口（交互式命令接口）

            例如： 命令行交互

        -   脱机命令接口（批处理命令接口）

            例如：批处理文件

    -   程序接口（系统调用）

        例如：user32.dll

    -   图形用户界面 GUI

*   作为最接近硬件的层次

    -   对硬件机器的拓展

        没有任何软件支持的计算机称为**裸机**，覆盖了软件的机器称为扩充机器或**虚拟机**

### 1.3 操作系统的特征

*   并发
    -   并发指两个或多个事件在同一时间间隔发生，宏观上事件是同时发生的，但微观上是交替发生的
*   共享
    -   资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用
        -   互斥共享：同一个时间段只允许一个进程访问资源
        -   同时共享：允许一个时间段内多个进程同时（宏观上）进行访问
*   虚拟
    -   虚拟是指将一个物理上的实体变为若干个逻辑上的对应物
    -   物理实体是实际存在，逻辑上对应物是用户感受的
    -   虚拟的实现分为**时分复用**和**空分复用**两种
*   异步
    -   多道程序环境下，允许多个程序并发执行，但是由于资源有限，进程的执行不可能一贯到底，而是“走走停停”，以不可预知的速度向前推进
*   并发和共享是操作系统两个最基本的特征

### 1.4 操作系统的分类

*   手工操作阶段
    -   主要缺点：用户独占全机，人机速度矛盾导致资源利用率极低
*   单道批处理系统
    -   引入脱机输入输出机属，并使用监督程序负责控制作业的输入输出
    -   监督程序是操作系统的雏形
    -   主要优点：缓解了一定程度的人机速度矛盾
    -   主要缺点：CPU 有大量时间在空闲等待 IO 完成，利用率依然很低
*   多道批处理系统
    -   计算机一次读入多道程序，并引入中断机属，由操作系统负责管理程序的运行，各个程序并发执行
    -   主要优点：多道程序并发执行，共享计算机资源，资源利用率大幅度提升，系统吞吐量增大
    -   主要缺点：用户响应时间长，没有人机交互功能
*   分时操作系统
    -   计算机以时间片为单位轮流为各个用户/作业服务，各个用户可以通过终端和计算机交互
    -   主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多用户同时使用同一台计算机，并且用户对计算机的操作相互独立
    -   主要缺点：不能优先处理紧急任务
*   实时操作系统
    -   计算机系统接收到外部信号后即时进行处理，并且在严格的时限内处理完事件
    -   主要特点：及时性和可靠性
    -   主要优点：能够先响应紧急任务，某些紧急任务不需要时间片排队
    -   实时操作系统分类
        -   硬实时系统：必须在绝对严格的规定时间内完成处理，如导弹控制系统和自动驾驶系统等
        -   软实时系统：允许偶尔违反时间规定，如火车票订票系统
*   其他操作系统
    -   网络操作系统
    -   分布式操作系统
    -   个人计算机操作系统

### 1.5 操作系统的运行机制和体系结构

#### 1.5.1 运行机制

*   指令：处理器能识别和执行的最基本命令
*   指令分为特权指令（不允许用户程序使用）和非特权指令两种
*   为了让 CPU 判断当前是否可以执行特权指令，CPU 分为两种处理器状态：用户态（目态，此时只能执行非特权指令）和核心态（管态，两种指令都可以执行）
*   用程序状态寄存器 PSW 的某个标识位区分当前处理器处于什么状态
*   程序分为内核程序（运行在核心态）和应用程序（运行在用户态）两种

#### 1.5.2 体系结构

*   操作系统的功能并不是全都不可或缺的，分为内核功能和非内核功能两类
*   内核在计算机系统的层次结构中接近计算机硬件
*   内核包含时钟管理、中断处理、原语（设备驱动， CPU 切换等）、系统资源管理（进程管理、储存器管理、设备管理）等
    -   时钟管理：实现计时功能
    -   中断处理：负责实现中断机制
    -   原语：
        -   处于操作系统最底层，最接近硬件的部分
        -   运行具有原子性
        -   运行时间较短，调用频繁
    -   系统资源管理
        -   进程管理
        -   存储器管理
        -   设备管理
    -   时钟管理、中断处理和原语是与硬件关联较为紧密的模块
    -   系统资源管理不一定会被划归内核
*   操作系统的体系结构
    -   大内核
        -   将操作系统的主要功能模块都作为系统内核，运行在核心态
        -   优点：高性能
        -   缺点：内核代码庞大，难以维护
    -   微内核
        -   只保留最基本的功能
        -   优点：内核功能少，结构清晰
        -   缺点：需要频繁地在核心态和用户态之间切换，性能较低

### 1.6 中断和异常

*   多道批处理系统中引入了中断机制
*   多道程序并发执行的本质：发生中断就意味着需要操作系统的介入，开展管理工作
*   中断发生后， CPU 立刻进入核心态，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
*   中断是 CPU 由用户态切换到核心态的唯一途径
*   中断的分类
    -   外中断（信号来源是 CPU 外部，与当前执行的指令无关）
        -   外设请求
        -   人工干预
    -   内中断（又称异常，信号来自 CPU 内部，与当前执行的指令有关）
        -   自愿中断：指令中断等
        -   强迫中断：硬件故障和软件中断等
    -   内中断的另一种分类方法
        -   trap（陷阱，陷入）：有意而为之的异常，如系统调用
        -   fault（故障）：由错误条件引起，可能被故障处理程序修复，如缺页
        -   abort（终止）：不可恢复的致命错误引起，终止处理程序不再将控制返回给引发终止的应用程序，如整数除零
*   外中断处理过程
    -   在用户态下执行完每个指令后， CPU 都要检查当前是否有外部中断信号
    -   如果检测到外部中断信号，保护被中断进程的 CPU 环境（如程序状态字 PSW ，程序计数器 PC 和各种通用寄存器等）
    -   根据中断信号类型转入相应的中断处理程序
    -   恢复原进程的 CPU 环境并退出中断，返回原进程继续往下执行

### 1.7 系统调用

#### 1.7.1 定义

*   应用程序通过系统调用请求操作系统的服务
*   系统中的各种共享资源由操作系统统一管理，在用户程序中，凡是与资源有关的操作（如储存分配，I/O 操作，文件管理等）都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成
*   系统调用可以保证系统的稳定性和安全性，防止用户进行非法操作
*   系统调用的相关处理在核心态下进行
*   系统调用的功能分类
    -   设备管理：完成设备的请求/释放/启动等功能
    -   文件管理：完成文件的创建/删除/读写功能
    -   进程控制：完成进程的创建/撤销/阻塞/唤醒等功能
    -   进程通信：完成进程之间的消息传递/信号传递等功能
    -   内存管理：完成内存的分配/回收等功能

#### 1.7.2 系统调用过程

*   高级语言的系统调用（汇编指令）封装在库函数中
*   系统调用流程
    -   传递系统调用参数 `int x`
    -   执行 trap 指令（用户态）
    -   执行系统调用相应服务程序（核心态）
    -   返回用户程序

## 2. 进程和线程

### 2.1 进程

#### 2.1.1 基本概念

*   程序段、数据段和 PCB 三部分组成进程实体（进程映像），通常将进程实体简称为进程
*   创建进程和撤销进程实际上是创建/撤销进程实体中的 PCB
*   进程从不同角度可以由不同定义
    -   进程是程序的一次执行过程
    -   进程是一个程序及其数据在处理机上顺序执行时所发生的活动
    -   进程时具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的独立单位
    -   进程是进程实体的运行过程，是系统改进型资源分配和调度的独立单位

#### 2.2 进程控制块 PCB

*   进程描述信息
    -   进程标识符 PID
    -   用户标识符 UID
*   进程控制和管理信息
    -   进程当前状态
    -   进程优先级
*   资源分配清单
    -   CS 段指针
    -   DS 段指针
    -   键盘/鼠标等
*   处理机相关信息
    -   各种寄存器值

#### 2.1.3 进程的组织

*   进程的组织方式
    -   链接方式
        -   按照进程状态，将 PCB 分为多个队列
        -   操作系统持有指向各个队列的指针
    -   索引方式
        -   根据进程状态的不同，建立几张索引表
        -   操作系统持有指向各个索引表的指针

#### 2.1.4 进程的特征

*   动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的，是进程最基本的特性
*   并发性：内存中由多个进程实体，各进程可并发执行
*   独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
*   异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供”进程同步机制“解决异步问题
*   结构性：每一个进程都会配置一个 PCB

### 2.2 进程的状态与转换

#### 2.2.1 进程的基本状态

*   运行态 Running ：占有 CPU ，并在 CPU 上运行
*   就绪态 Ready ：已经具备运行条件，但是由于没有空闲 CPU 而暂时不能运行
*   阻塞态 Blocked / Waiting ：因等待事件不能运行
*   创建态 New ：进程正在被创建，操作系统为进程分配资源、初始化 PCB
*   终止态 Terminated ：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销 PCB

#### 2.2.2 进程状态的转换

进程状态的转换如下图所示

### 2.3 进程控制

#### 2.3.1 基本概念

*   进程控制的主要功能是对系统中的所有进程实施有效的管理
*   进程控制具有创建新进程、撤销已有进程、实现进程状态转换等功能
*   进程控制需要原子操作，因此用原语实现进程控制
*   原语采用关中断指令和开中断指令实现
*   控制进程的原语需要做三件事情
    -   更新 PCB 中的信息，如修改进程状态标志、将运行环境保存到 PCB ，从 PCB 恢复运行环境等
        -   所有的进程控制原语一定都会修改进程状态标志
        -   剥夺当前运行进程的 CPU 使用权必然需要保存其运行环境
        -   某进程开始运行前必然要恢复其运行环境
    -   将 PCB 插入合适的队列
    -   分配/回收资源

#### 2.3.2 原语

> TODO: 原语列表

### 2.4 进程通信

#### 2.4.1 共享储存

*   为了保证安全，一个进程不能直接访问另一个进程的地址空间，需要使用操作系统提供的方法
*   操作系统为进程分配一个共享空间，供两个进程**互斥**地访问
*   操作系统只负责提供共享空间和同步互斥工具
*   基于储存区的共享：在内存中划出一块共享储存区，数据的形式和存放位置都由进程控制

#### 2.4.2 管道通信

*   管道是用于连接读写进程的一个共享文件（实际上是在内存中开辟的一个固定大小的缓冲区），只能提供半双工的通信
*   各进程访问管道应该是**互斥**的
*   数据以字符流的形式写入管道，当管道写满时，写进程的 `write()` 被阻塞，等待读进程取走数据
*   读进程将数据读出后，管道变空，此时读进程的 `read()` 被阻塞
*   如果管道没有写满则不允许读取，如果没有读空则不允许写入
*   数据一旦从管道中读出就被抛弃，这一位置额读进程**最多只能有一个**，否则会有读错数据的情况

#### 2.4.3 消息传递

*   进程间的数据以格式化的消息为单位，进程通过操作系统提供的原语进行数据交换
*   直接通信方式：消息直接挂到接收进程的消息缓冲队列上
*   间接通信方式：消息要先发送到中间实体（信箱）中

### 2.5 线程

#### 2.5.1 基本概念

*   线程是一种“轻量级进程”，是一个基本的 CPU 执行单元，也是程序执行流的最小单位
*   引入线程后，进程只作为除 CPU 之外的系统资源的分配单元
*   引入线程机制后的变化
    -   资源分配调度
        -   传统进程机制中，进程是资源分配调度的基本单位
        -   引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
    -   并发性
        -   传统进程机制中，只能进程间并发
        -   引入线程后，各线程之间也能并发
    -   系统开销
        -   传统进程机制中，并发会导致运行环境频繁切换，系统开销较大
        -   引入线程后，线程间并发如果在同一进程下，则不需要切换进程环境，系统开销减小
*   线程的属性

> TODO: 线程属性

#### 2.5.2 线程的实现方式

*   用户级线程
    -   由应用程序通过线程库实现
    -   所有的线程管理工作都由应用程序负责
    -   线程切换可以在用户态下完成，无需操作系统干预
    -   用户级线程对用户不透明，对操作系统透明
*   内核级线程
    -   由操作系统完成线程管理、调度和切换
    -   线程切换在核心态下完成
*   实际实现时可以采用两者组合的方式，即将用户线程映射到内核线程上

### 2.6 处理机调度

#### 2.6.1 高级调度

*   高级调度（作业调度）：按照一定的原则从外存上处于后备队列的作业中挑选一个或多个作业，分配内存等必要资源并建立 PCB ，以使它们获得竞争处理机的权利
*   高级调度是外存与内存之间的调度，每个作业只调入一次，调出一次。调入时会建立对应的 PCB ，调出时会撤销对应的 PCB
*   高级调度主要是调入问题，因为调出的时机必然是作业运行结束的时机

#### 2.6.2 中级调度

*   中级调度（内存调度）：决定将哪个处于挂机状态的进程重新调入内存
*   引入虚拟储存技术后，可将暂时不能运行的进程通过挂起原语调入外存等待
*   PCB 不会随挂起原语调用到外存，而是会常驻内存，操作系统通过内存中的 PCB 保持对各个进程的监控和管理
*   被挂起的进程 PCB 会被放入挂起队列中
*   加入挂起唤醒原语后，五状态模型变为七状态模型

#### 2.6.3 低级调度

*   低级调度（进程调度）：按照某种方法和策略从就绪队列中选取一个进程，将 CPU 分配给它
*   进程调度是操作系统中最基本的一种调度
*   进程调度的频率很高，约几十毫秒一次
*   进程调度的时机
    -   当前运行的进程主动放弃 CPU 时，如进程正常终止，发生异常，进程请求阻塞等
    -   当前运行的进程被动放弃 CPU 时，如时间片用完，有更紧急的事件需要处理，更高优先级的进程进入就绪队列等
    -   处理中断的过程中、进程在操作系统内核程序临界区中和原子操作过程中不能进行进程的调度与切换
*   进程调度的方式
    -   非剥夺调度方式（非抢占方式）：只允许进程主动放弃 CPU ，在运行过程中即使有更高优先级任务到达，当前进程依然继续占用 CPU ，直到进程终止或主动进入阻塞
    -   剥夺调用方式（抢占方式）：进程执行过程中，如果有更高优先级任务到达，立即暂停正在执行的进程并将 CPU 分配给刚到达的进程

#### 2.6.4 调度算法

*   调度算法的评价指标

    -   CPU 利用率：CPU 忙碌时间占总时间的比例
    -   系统吞吐量：单位时间内完成作业的数量
    -   周转时间：从作业被提交开始到作业完成的时间间隔，包括高级调度、低级调度、进程执行和进程等待 I/O 的时间
    -   带权周转时间：周转时间除以作业实际运行时间
    -   等待时间：作业处于等待 CPU 状态的时间之和
    -   响应时间：从用户提交请求到首次产生响应的时间

*   FCFS（先来先服务）

    -   按作业的到达顺序进行服务
    -   用于作业调度时，考虑哪个作业先到达后备队列；用于进程调度时，考虑哪个进程先到达就绪队列
    -   是非抢占式的算法
    -   优缺点
        -   优点：公平，算法相对简单
        -   缺点：排在长作业后的短作业等待时间过长，带权周转时间很大，对长作业有利，对短作业不利
    -   不会导致饥饿（某作业长期得不到服务）

*   SJF（短作业优先）

    -   最短（要求服务时间）的作业优先得到服务
    -   用于进程调度时，称为 SPF（短进程优先）算法
    -   非抢占式，但是有抢占式的改进算法 （ SRTN ，最短剩余时间优先）
    -   在所有进程几乎同时到达时，SJF 的平均等待时间和平均周转时间最少；一般情况下 SRTN 的平均等待时间和平均周转时间最少
    -   优缺点
        -   优点：”最短“平均等待时间和平均周转时间
        -   缺点：对短作业有利，对长作业不利；作业的运行时间由用户提供，不一定真实
    -   会导致饥饿，甚至会导致长作业饿死

*   HRRN （高响应比优先）

    -   每次调度时优先计算各个作业的响应比，选择响应比较高的作业优先服务。$响应比=\frac{等待时间+要求服务时间}{要求服务时间}$
    -   非抢占式，只有当前作业主动放弃 CPU 时才需要计算响应比重新调度
    -   优缺点
        -   优点：综合考虑了等待时间和运行时间，等待时间相同时运行时间短的优先，长作业等待时间越久响应比也越大，从而避免了长作业饥饿
        -   缺点：用户交互性差
    -   不会导致饥饿

*   RR（时间片轮转调度算法）

    -   公平、轮流为各个进程服务，让每个进程在一定时间间隔内都能得到响应
    -   按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，若进程未在一个时间片内执行完则重新放入就绪队列队尾
    -   是抢占式算法，由时钟装置发出时钟中断通知 CPU 时间片已到
    -   如果时间片过大，则 RR 退化为 FCFS
    -   优缺点
        -   优点：公平，响应快，适合分时系统
        -   缺点：高频率的进程切换，不区分任务紧急程度
    -   不会导致饥饿

*   优先级调度算法

    -   调度时选择优先级最高的作业
    -   抢占式和非抢占式都有
    -   就绪队列未必只有一个，可以按照不同优先级来组织，另外也可以优先级高的进程排在更靠近队头的位置
    -   根据优先级是否可变，分为静态优先级和动态优先级
    -   通常系统进程优先级高于用户进程，前台进程优先级高于后台进程，I/O 繁忙型进程优先级高于 CPU 繁忙型（计算型）进程
    -   动态优先级调整时，如果进程在就绪队列中等待很长时间，可以提高优先级；如果占用 CPU 时间过长，可以降低优先级；如果频繁进行 I/O 操作，可以适当提升优先级
    -   优缺点
        -   优点：灵活调整各种作业的偏好程度，适用于实时操作系统
        -   缺点：高优先级进程过多时，会导致低优先级进程饥饿
    -   会导致饥饿

*   多级反馈队列调度算法

    -   多级队列调度是对其他调度算法的折中权衡
        -   设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
        -   新进程到达时先进入第一级队列，按 FCFS 原则排队等待分配时间片
        -   如果用完时间片进程还未结束，放入下一级队列队尾（如果已经在最下级则直接放入队尾）
        -   只有第 k 级队列空时，才会为 k+1 级对头的进程分配时间片
    -   抢占式算法，在进程运行时，如果更上级队列进入了一个新进程，则新进程抢占 CPU ，原来运行的进程放入其所在级别队列的队尾
    -   优缺点
        -   优点：对各类进程相对公平，新到达进程可以快速得到响应，短进程只需要较少时间就可以执行完成，不需要估计进程运行时间；可以灵活调整对各类进程的偏好程度（如将因 I/O 阻塞的进程重新放回原队列使 I/O 繁忙型进程保持较高优先级）
        -   缺点：低等级队列的进程可能长期得不到服务
    -   会导致饥饿

### 2.7 同步与互斥

#### 2.7.1 线程同步

*   同步（直接制约关系）是指为完成某种任务而建立的两个或多个进程之间，因为需要在某些位置上协调它们的工作次序而产生的制约关系

    -   进程间的直接制约关系源于它们之间的相互合作

#### 2.7.2 线程互斥

-   系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内仅允许**一个进程**访问该资源

-   一个时间段内只允许一个进程使用的资源称为临界资源

*   互斥（间接制约关系）指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程结束访问释放资源后，另一个进程才能去访问临界资源

    -   对临界资源的互斥访问，在逻辑上可以分为如下四个部分

    ```c++

        do
        {
            EntrySection(); 		// 进入区
            CriticalSection(); 	// 临界区
            ExitSection(); 	    // 退出区
            RemainderSection(); 	// 剩余区
        } while(true)

    ``` 
*   每个区域所做的工作如下

    -   进入区负责检查是否可进入临界区，若可进入，则设置正在访问临界资源的标志，即**上锁**
    -   临界区是访问临界资源的代码
    -   退出区负责解除正在访问临界资源的标志，即**解锁**
    -   剩余区做其他处理

*   实现临界资源互斥访问需要遵循以下原则

    -   空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
    -   忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
    -   有限等待：对请求访问的进程，应保证其能在有限时间内进入临界区
    -   让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

#### 2.7.3 进程互斥的实现方法

> 本节中用 `Critical` 表示临界区，用 `Remainder` 表示剩余区

*   单标志法：两个进程在访问完成后会把临界区使用权限交给另一个进程，即每个进程进入临界区的权限只能被另一个进程赋予

    ```c++
        int turn = 0;	// turn 表示当前允许进入临界区的进程号

        // 进程 P0
        {
            while(turn != 0)    // 进入区
            Critical;           // 临界区
            turn = 1;           // 退出区
            Remainder;          // 剩余区
        }

        // 进程 P1
        {
            while(turn != 1)    // 进入区
            Critical;           // 临界区
            turn = 0;           // 退出区
            Remainder;          // 剩余区
        }
    ```

    -   对于临界区的访问，一定是按照 P0 $\rarr$ P1 $\rarr$ P0 $\cdots$ 的顺序进行的
    -   如果此时允许 P0 进入临界区，但 P0 一直不访问，P1 也就一直不能访问空闲的临界区，违背空闲让进原则

*   双标志先检查法：设置一个 `bool` 型数组用来标记各进程想进入临界区的意愿，每个进程在进入临界区前先检查当前有没有别的进程想进入临界区

    ```c++
        bool flags[2] = {false, false};

        // 进程 P0
        {
            while(flag[1]);             //- 1
            flag[0] = true; Critical;   //- 2
            flag[0] = false;            //- 3
            Remainder;                  //- 4
        }

        // 进程 P1
        {
            while(flag[0]); //- 5
            flag[1] = true; Critical; //- 6
            flag[1] = false; //- 7
            Remainder; //- 8
        }
    ``` 

    - 当执行顺序是 1-5-2-6-... 时， P0 和 P1 将同时访问临界区，违背忙则等待原则
    - 原因是进入区的检查和上锁操作不是一次性处理完的，其中可能会存在进程切换

*   双标志后检查法：先检查法的改进，在检查之前先上锁。具体做法是将上述代码的 `flag[i] = true` 提到 `while` 循环之前。可能会导致两个进程都锁住临界区而无法进入，违背了空闲让进和有限等待。

*   Peterson 算法：在双标志后检查法中，如果双方都抢着进入临界区，可以让进程选择主动让对方进入临界区

    ```c++
        bool flag[2] = {false, false};
        int trun = 0;   // 表示优先让哪个进程进入临界区

        // 进程 P0
        {
            flag[0] = true;
            trun = 1;
            while(flag[1] && trun == 1);
            Critical;
            flag[0] = false;
            Remainder;
        }

        // 进程 P1
        {
            flag[1] == true;
            trun = 0;
            while(flag[0] && trun == 0); // 对方想进入，并且最后一次是自己让出进入权，那么自己等待
            Critical；
            flag[1] = false;
            Remainder;
        }
    ```

    - Peterson 算法解决了空闲让进、忙则等待和有限等待原则，但是没有解决让权等待原则

-   中断屏蔽方法：利用中断的原子性，在访问临界区前关中断，访问完成后开中断

    - 优点：简单，高效
    - 缺点：不适用于多处理机，只适用于操作系统内核进程

-   TestAndSetLock 指令：由硬件实现的原子指令，也称 TSL 指令，C 语言描述如下

    ```c++
        // lock 表示临界区是否加锁
        bool TestAndSet(bool& lock)
        {
            bool old = lock;
            lock = true;   // 无论之前是否加锁，现在都锁上
            return old;     // 返回 lock 原来的值
        }

        // 进程 P0
        {
            while(TestAndSet(lock));
            Critical;
            lock = false;
            Remainder;
        }
    ```

    - 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
    - 缺点：不满足让权等待原则，暂时无法进入临界区的程序会占用 CPU 并循环 TSL 指令，从而导致忙等

-   Swap 指令：也称 XCHG 指令，由硬件实现的原子指令，C 语言描述如下

    ```c++
        void Swap(bool& a, bool& b)
        {
            bool tmp = a;
            a = b;
            b = tmp;
        }

        // 进程 P0
        {
            bool old = true;
            while(old == true) Swap(lock, old);
            Critical;
            lock = false;
            Remainder;
        }
    ```

    - 优缺点和 TSL 指令相似

### 2.8 信号量机制

#### 2.8.1 信号量

- 用户可以通过操作系统提供的一对原语来对信号量进行操作

- 信号量是一个变量，可以用一个信号量来表示某种资源的数量

- 原语是一种特殊程序段，由关中断/开中断指令实现，其执行只能一气呵成，不可被中断

- wait 和 signal 原语常简写为 P/V 操作（源自荷兰语 proberen ”检测“ 和 verhogen ”增量“)

- 整型信号量

    - 用一个整数型变量作为信号量，用来表示某种资源的数量

    - 只由三种操作：初始化和 P/V 操作

        ```c++
            int S = 1;  // 系统中有一台打印机

            void P(int S)
            {
                while(S <= 0); // 进入区。如果资源数不够，就一直循环等待
                S -= 1;
            }

            void V(int S)
            {
                S += 1; // 退出区，使用完资源后释放
            }

            // 进程 P0
            {
                P(S);   // 进入区，申请资源
                Critical；
                V(S);   // 退出区，释放资源
                Remainder;
            }
        ```

    - 整型信号量检查和上锁操作是原子操作，避免并发异步导致的问题，但是不满足让权等待原则

- 记录型信号量

    - 记录型信号量不仅保存剩余资源数，还保存一个指向等待队列的指针

        ```c++
            struct Semaphore
            {
                int value;          // 剩余资源数
                ProcessList list;   // 等待队列
            };

            void P(Semaphore S)
            {
                S.value -= 1;
                if(S.value < 0)
                {
                    Block(S.list);  // 如果剩余资源数不足，使用 block 原语
                                    // 进程从运行态进入阻塞态，并挂载到 S 的等待队列
                }
            }

            void V(Semaphore S)
            {
                S.value += 1;
                if(S.value <= 0)
                {
                    Wakeup(S.list); // 释放完成后，如果还有进程在等待资源
                                    // 使用 wakeup 原语从等待队列唤醒一个进程
                }
            }
        ```

    - 记录型信号量实现了让权等待原则

#### 2.8.2 进程互斥与进程同步

- 信号量机制实现进程互斥

    - 分析并发进程的关键活动，划定临界区

    - 设定互斥信号量 mutex ，初始值为 1

    - 在临界区前执行 `P(mutex)` ，临界区之后执行 `V(mutex)`

- 信号量机制实现进程同步

    - 分析什么地方需要实现同步关系

    - 设置同步信号量 S ，初始值为 1
    
    - 在前操作之后执行 `V(S)` ，在后操作之前执行 `P(S)`

- 信号量实现前驱关系

    - 按照进程同步方式，为每一对前驱关系设置同步变量，并执行 V/P 操作

- 互斥信号量的 P 操作一定要在同步信号量的 P 操作之后，否则可能导致死锁